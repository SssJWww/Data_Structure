线性结构
    最常用的数据结构 数据之间存在一对一的线性关系
    顺序存储（数组） 链式存储结构（链表）
    常见的线性结构 数组，队列，栈，链表
非线性结构
    二维数组，多维数组，广义表，树结构，图结构
稀疏数组 sparse array
    当一个数组中大部分元素是0，或者其他大量同样的值时，可以用稀疏数组(sparse array)进行保存
    处理方法：
        记录数组一共几行几列，有多少个不同的值
        把具有不同值的元素的行列及数值记录在一个小规模的数组中，从而缩小程序的规模
        行 列 值    <-------    0 0 1 0
    [0] 3  4  3                0 5 0 0
    [1] 0  2  1                8 0 0 0
    [2] 1  1  5
    [3] 2  0  8

    二维数组转稀疏数组的思路
    1. 遍历原始的二维数组，得到有效数据的个数sum
    2. 根据sum创建稀疏数组sparseArr int[sum+1][3]
    3. 将二维数组的有效数据存入到稀疏数组中

    稀疏数组转二维数组的思路
    1. 先读取稀疏数组的第一行，根据第一行数据创建原始二维数组
    2. 再读取稀疏数组后几行的数据，并赋给原始的二维数组即可

队列
    先进先出

链表(LinkedList)
    链表是有序的列表
    链表是以节点的方式来存储，是链式存储
    单链表的每个节点包含date域，next域 指向下一个节点
    链表分为带头节点的链表和不带头节点的链表

    双指针链表

    单向环形列表解决Josephus（约瑟夫）问题

栈(stack)
    先入后出 first in last out(FILO)
    栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表.
    允许插入和删除的一端，为变化的一端，称为栈顶TOP，另一端为栈底bottom

    通过栈实现表达式运算的思路
    1.通过index来遍历我们的表达式
    2.如果发现是数字则入数栈  numStack
    3.如果发现是符号则分为两种情况
        3.1如果符号栈为空，入符号栈  operatorStack.
        3.2若果符号栈中有操作符，则进行比较.
            如果当前的操作符优先级小于等于栈内操作符
            则需要将数栈中pop出两个数字，符号栈pop出一个符号，进行运算将得到的结果入数栈，再将当前操作符入栈.
            如果当前的操作符优先级大于栈中操作符，直接入栈不计算.
    4.当扫描完毕过后，就顺序的从数栈和符号栈中pop出相应的数和符号并运算.
    5.最后数栈只会有一个数字就是结果.

    前缀(波兰表达式)，中缀(infix notation)，后缀表达式(逆波兰表达式)
        前缀表达式求值(符号都在前面)
            1.从右向左扫描表达式，遇到数字，将数字压入栈中，遇到符号就弹出两个数栈数字 运算后压入栈中
        后缀表达式 (运算符位于操作数之后)  后缀表达式更符合计算机的语言
            后缀表达式求值的过程
            1.从左至右扫描表达式，遇到数字将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符进行做相应运算，将
               结果压入栈中，重复上述过程.

        中缀表达式转后缀表达式的私服分析
            1.初始化两个栈，运算符栈s1和储存中间结果的栈s2
            2.从左到右扫描中缀表达式
            3.遇到操作数时压入数栈
            4.遇到运算符的时候，比较其与s1栈顶操作符的优先级
                4.1若s1为空栈或栈顶运算符为左括号(，则直接将此运算符入栈
                4.2若优先级比栈顶的高，也将运算符入栈
                4.3否则 将运算符符栈顶的运算符弹出并压入到数栈中，继续与弹出后的运算符栈进行比较重复4.1
            5.遇到括号时
                5.1如果左括号，直接压入到操作符栈中
                5.2如果是右括号，则依次弹出s1栈顶的运算符，压入数栈中，直到遇到左括号为止，此时将这对括号丢弃
            6.重复2至5的步骤，直到中缀表达式扫描完毕
            7.将s1中剩余的运算符依次弹出压入数栈中
            8.逆向弹出数栈元素，输出即为后缀表达式(逆波兰表达式)

递归问题 recursion
    递归就是自己调用自己，每次调用时传入的变量不一样，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁.
    递归调用规则
        attention：java虚拟机(JVM)会开辟一个栈空间 一个堆空间 一个代码区(常量)
        1.当程序执行到一个方法时，就会开辟一个受保护的独立的空间(栈)
        2.方法的局部变量是独立的，不会相互影响
        3.如果方法中使用的是引用类型的变量则会共享使用
        4.递归必须向推出递归的条件逼近，否则就是死循环了
        5.当一个方法执行完毕，或遇到return，就会返回.遵守谁调用就将结果返回给谁，同时当方法执行完毕或返回时
           方法就执行完毕

    八皇后问题(回溯算法)
    任意两个皇后都不能处于同一行，同一列或同一斜线上，问有多少种摆法

排序算法 algorithm sort
    外部排序：数据量过大，无法全部加载到内存中，需要接住外部存储进行排序
    内部排序：将需要处理的所有数据都加载到内部存储器中进行排序
        插入排序
            直接插入排序
            希尔排序
        选择排序
            简单选择排序
            堆排序
        交换排序
            冒泡排序
            快速排序
        归并排序
        基数排序
    算法的时间复杂度
        计算1-100所有数字之和
        1。for(int i=1;i<=100;i++){count+=i} n次
            T(n) = n+1  n次+最后判断一次
           count = (1+100)*100/2
            T(n) = 1  只执行一次
        Conclusion：统计时间复杂度的时候，常数项可以省略
                                      低次项可以忽略
                                      系数可以忽略
        常见的时间复杂度
            O(1),O(log2n),O(n),O(nlog2n),O(n^2),O(n^3),O(n^k),O(2^n) 由小到达

            while(i<n) {
                i*=2            i=n=2^x  x = log2n
            }

        平均时间复杂度和最坏时间复杂度

    冒泡排序 基本思想
        通过对待排序序列从前向后，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素
        主键向前或向后部移动。

    选择排序 基本思想
        第一次从arr[0]到arr[length-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[length-1]中进行交换以此类推。

    插入排序 基本思想
        把n个待排序的元素看成为一个有序表一个无序表，开始时有序表只包含一个元素，无序表中有n-1个元素，排序过程中
        每次从无序表中取出一个元素，把它的排序码依次与有序元素的排序码进行比较，将它插入到有序表中的适当位置，
        使之成为新的有序表

    希尔排序(缩小增量排序)
        对数组进行分组，按各个小分组进行插入排序
        两种方法实现
            1。交换法（效率很差）
            2。插入法（类似于插入排序 效率很好）

    快速排序 基本思想 QuickSort
        是对冒泡排序的一种改进，通过一趟排序将要排序的数据分割成独立的两部分，找到一个中轴点其中一部分的所有数据
        都比另外一部分数据要小，然后再按照此方法对这两部分数据分别进行快速排序，达到整个数据变成有序数列

    归并排序(Merge Sort) 基本思想
        利用归并思想实现的排序方法，该算法采用经典的分治(divide-and-conquer)策略(分治法将问题分成一些小问题然后递归求解)
        而治的阶段则将分的阶段得到的答案修补在一起

    基数排序(radix sort)(桶排序) 基本思想
        将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后从最低位开始，依次进行一次排序。
        这样从最低位排序一直到最高位排序完成后，数列就变成一个有序数列

常用排序算法总结和对比
    排序算法    平均时间复杂度     最好情况        最坏情况     稳定性
    冒泡排序        O(n^2)        O(n)          O(n^2)     稳定
    选择排序        O(n^2)        O(n^2)        O(n^2)     不稳定
    插入排序        O(n^2)        O(n)          O(n^2)     稳定
    希尔排序        O(n log n)                             不稳定
    归并排序        O(n log n)                             稳定
    快速排序        O(n log n)                             不稳定

查找
    线性查找(线性查找)
        直接遍历即可
    二分查找(折半查找) ：对一个有序数组进行二分查找
        思路分析：首先确定该数组中间的下标
                然后需要查找的数和数组中间下标进行比较
                if findVal > array[mid] 然后向右递归查找
                if findVal < array[mid] 然后向左递归查找
                if findVal == array[mid] 直接返回即可
    插值查找 : 也要求查找的数组是有序数组
        middle = left + (high-left)* (target-array[left])/(array(high)-array(left))

    斐波那契查找(黄金分割法) 黄金分割值 0.618
    斐波那契数列 {1,1,2,3,5,8,13,21,34,55} 相邻两个数比值主键接近0.618黄金分割值
